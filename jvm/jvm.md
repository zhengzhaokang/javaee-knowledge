1.JVM的组成部分？

```
JVM包含4部分：运行时数据区、类加载器、执行引擎、本地库接口。
运行时数据区最关键，主要包含五部分：
堆：线程共享，大部分对象在这里分配。
方法区：线程共享，存储已经被虚拟机加载的类信息，比如常量、静态变量。
虚拟机栈：存储java方法的局部变量、方法出口等。
本地方法栈：与虚拟机栈作用一样。
程序计数器：程序当前执行的字节码行号。
```

2、堆的内部结构？

```
堆是垃圾收集器管理的主要区域，因此也被称作 GC堆（Garbage Collected Heap）。
JDK7及之前，堆分为三部分：新生代、老年代、永久代。
Eden区、两个 Survivor 区 S0 和 S1 都属于新生代，中间是老年代，下面是永久代。 JDK8后，
永久代被 Metaspace(元空间) 取代，元空间使用的是直接内存 。

对象优先在 Eden 区分配。 当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 大对象直接进入老年代 
长期存活的对象将进入老年代
```

3、类在什么时候会被加载？

```
遇到new对象
类被反射调用
加载子类时，父类被自动加载
```

4、类的加载过程？

```
加载：通过全限定名，获取此类的二进制字节流
验证：验证字节流中的文件格式、元数据、符号引用是否符合JVM规范
准备：为类的静态变量分配空间，并且初始化这些字段
解析：常量池内的符号引用替换成直接引用
初始化：在准备阶段，变量被赋予了初始值，初始化阶段会按照用户编写的代码重新初始化
```

详细版本：

```
java类的加载过程是一个由Java虚拟机（JVM）执行的复杂过程，它涉及到将类的.class文件（或等效的字节码）加载到JVM中，
然后将其转换成运行时数据结构，以便JVM能够使用这些类来执行程序。这个过程大致可以分为以下几个阶段：

加载（Loading）：
这是类加载过程的第一个阶段。在这一阶段，JVM通过类加载器（ClassLoader）找到类的.class文件，并将其字节码内容加载到JVM的
内存中，生成一个代表该类的java.lang.Class对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。
链接（Linking）：
链接过程分为三个阶段：验证（Verification）、准备（Preparation）和解析（Resolution）。
验证（Verification）：确保被加载的类的正确性，包括文件格式验证、元数据验证、字节码验证和符号引用验证等。
准备（Preparation）：为类的静态变量分配内存，并设置默认的初始值（注意，这里只是分配内存并设置初始值，如int类型变量
初始化为0，对象类型变量初始化为null，而不是将变量赋值为代码中定义的初始值）。
解析（Resolution）：将类、接口、字段和方法的符号引用转换为直接引用。这一步是可选的，如果符号引用在编译时就能确定其
直接引用，则可以在类加载的解析阶段之前进行解析。
初始化（Initialization）：
在这个阶段，JVM才真正开始执行类中定义的Java代码（或者说是字节码）。这个阶段是执行类构造器<clinit>()方法的过程。
<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块（static block）中的语句合并产生的，编译器收集的
顺序由语句在源文件中出现的顺序决定。
需要注意的是，类的初始化只会被执行一次。
使用（Using）：
类被加载、链接、初始化后，就可以被JVM使用了。JVM会生成类的实例（对象），并通过这些实例来调用类的方法。
卸载（Unloading）：
当类不再被需要时，JVM会将其卸载，即释放该类的相关信息所占用的内存资源。但这个过程并不是由Java程序直接控制的，
而是由JVM的垃圾回收机制来完成的。
以上就是Java类加载的大致过程。这个过程中，类加载器（ClassLoader）扮演了至关重要的角色，它负责将类的.class文件加载
到JVM中。Java中的类加载器采用双亲委派模型（Parent Delegation Model），即一个类加载器在尝试加载某个类时，会首先将
其委派给父类加载器，如果父类加载器无法加载该类，则再由自己加载。这种模型有助于保证Java程序的稳定性和安全性。
```

5、什么是双亲委派模型？有没有办法打破？

```
当需要加载一个class文件的时候，首先会把这个class的查询和加载委派给父加载器去执行，
如果父加载器都无法加载，再尝试自己来加载这个class。

双亲委派并不是一个强制性的约束模型，可以通过一些方式去打破：

1. 继承ClassLoader抽象类，重写loadClass方法，在这个方法可以自定义要加载的类使用的类加载器。

2. 使用线程上下文加载器，通过Thread类的setContextClassLoader()方法来设置当前类使用的类加载器类型。

Java提供了多种类型的类加载器，以适应不同的加载需求：
启动类加载器（Bootstrap ClassLoader）：也称为根类加载器，负责加载JVM的核心类库，如java.lang.Object等。
它是JVM的一部分，通常由本地代码实现，不是Java类。
扩展类加载器（Extension ClassLoader）：负责加载Java的扩展类库，这些类库通常位于jre/lib/ext目录下或者
由系统属性java.ext.dirs指定的目录中。
系统类加载器（System ClassLoader）：也称为应用程序类加载器（Application ClassLoader），负责加载应用程序的类路径
（CLASSPATH）上指定的类文件。它是扩展类加载器的子类。
自定义类加载器：开发人员可以根据需要实现自己的类加载器，以满足特定的加载需求。
```

6.如何判断对象应该GC？

```
1. 引用计数法
给每个对象一个引用计数器，有地方引用它时，计数器加1；引用失效时，计数器减1，计数器的值为0时，可以GC。 
缺点：循环引用无法回收，A和B都置为null，但内部存在互相引用，都不能被回收。
2. 可达性分析
从GC Roots开始向下搜索，搜索所走过的路径称为引用链。
当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
```

7.GC Roots可以是哪些元素？

```
虚拟机栈中引用的对象，比如：各个线程被调用的方法中使用到的参数、局部变量等。
方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量
方法区中常量引用的对象，比如：字符串常量池（StringTable）里的引用 所有被同步锁synchronized持有的对象
```

8、**GC算法了解吗？**

```
1. 引用计数法
给每个对象一个引用计数器，有地方引用它时，计数器加1；引用失效时，计数器减1，计数器的值为0时，可以GC。
缺点：循环引用无法回收，A和B都置为null，但内部存在互相引用，都不能被回收。
2. 标记清除法
标记：从根节点开始标记引用的对象。
清除：未被标记引用的对象就是垃圾对象，可以被清理。
缺点：效率较低，标记和清除两个动作都需要遍历所有的对象；内存碎片化严重。
3. 标记压缩算法
标记压缩算法是在标记清除算法的基础之上，将存活的对象压缩到内存的一端，然后清理边界以外的垃圾，从而解决了碎片化的问题。
缺点：移动内存的步骤，对效率一定影响。
4. 复制算法
将内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空。
当垃圾对象较多时，需要复制的对象就会少，效率比较高，反之则不适合，会浪费大量内存空间。
5. 分代回收算法
(1) 年轻代使用复制算法
GC开始前，对象只存在于Eden区和名为From的Survivor区，Survivor区To是空的。
紧接着GC，Eden区中所有存活对象，年龄达到一定值的对象会被移动到年老代，没有达到阀值的对象会被复制到To区域。
GC会一直重复这样的过程，直到To区被填满，To区被填满之后，会将所有对象移动到年老代。
(2) 老年代使用标记整理算法
老年代对象的存活率比较高，一直复制过来，复制过去，没啥意义，浪费时间。所以针对老年代提出了“标记整理”算法。
老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。如果系统频繁出现老年代的Full GC垃圾回收，
会导致系统性能被严重影响，出现频繁卡顿的情况。
```

9、**JVM有哪些垃圾收集器？**

```
1. 串行垃圾收集器：使用单线程进行垃圾回收，垃圾回收时所有线程都要暂停，等待垃圾回收的完成，这种现象称之为STW
 （Stop-The-World）
2. 并行垃圾收集器：将串行垃圾收集器的单线程改为了多线程，缩短垃圾回收的时间，但仍会暂停应用程序。
3. ParNew垃圾收集器/Parallel垃圾收集器：用在年轻代上的并行垃圾收集器
4. CMS垃圾收集器
CMS是一款并发的、使用标记-清除算法的垃圾回收器，使用在老年代。
GC过程：
初始标记：扫描和根对象「直接关联」的对象，并作标记，这个过程虽然STW，但很快就完成了。
并发标记：在初始标记的基础上继续向下追溯标记，这个过程与用户线程并行运行。
并发预清理：与用户线程同时运行
重新标记：并发阶段会出现新的垃圾，但不多，所以可以STW进行追加标记
并发清除：与用户线程同时运行
CMS缺点：有多个并行阶段，堆空间要预留更多内存来为新对象分配内存，降低了堆空间的利用率。
5. G1垃圾收集器
G1在jdk7正式引入，jdk9中变成默认垃圾收集器，替代CMS。
G1最大的特点是取消了年轻代、老年代的物理划分，取而代之的是将堆划分为若干个区域（Region），这些区域中包含了逻辑上的
年轻代、老年代。
年轻代的垃圾收集，依然采用STW的方式，将存活对象拷贝到老年代或Survivor空间，不会有cms的内存碎片问题。
在G1，有一个特殊的区域，叫Humongous区域。专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。
java -XX:+PrintCommandLineFlags -version
Java 8通过默认使用Parallel Scavenge和Parallel Old作为垃圾回收器。 -XX:+UseParallelGC Java 9 默认 G1垃圾收集器 
```

10、JVM调优的方法有哪些？

```
1. 内存调优：调整-Xms 和 -Xmx 参数，即初始堆和最大堆大小；调整-Xmn或-XX:NewRatio参数，即新生代与老年代的比例；
调整-XX:SurvivorRatio参数，即Eden区和Survivor区的比例。

2. 垃圾回收调优：使用-Xloggc:<file-path>参数；分析GC日志，了解GC事件的频率和持续时间，以及内存分配和回收的模式。

3. 性能监控和分析：使用性能监控工具，如 JConsole，对 JVM 运行时进行监控和分析，发现性能瓶颈和问题点。

4. 调整线程栈大小：使用-Xss参数设置每个线程的栈大小，以减少内存使用或避免栈溢出错误。

5. 代码层面的优化：及时释放不需要的资源；避免创建大对象。
```

11、内存泄漏/溢出可能的原因?如何解决?

```
静态对象过大/过多：静态对象的生命周期与JVM一致，GC不会清除它，可以检查static用法
存在未关闭的连接：检查是否存在只打开，没有关闭逻辑的链接
内存中加载数据量过大：大批量数据的单次查询改为分页查询
集合对象使用完后未清空：可使用 clear() 方法进行清除
JVM启动参数设定过小：增大JVM启动参数（-Xms初始内存，可以与-Xmx相同；-Xmx 最大可用内存 ）
```

12、java对象的内存结构？

```
java对象由对象头、对象体、对齐字节三部分组成。
对象头： Mark Word：表示对象的线程锁状态 Klass Word：指向方法区中对应的Class信息 数组长度：可选，对象是数组时才会有这部分
对象体：保存对象的属性和值
对齐字节：减少堆内存碎片
```

13、深拷贝和浅拷贝的区别？

```
浅拷贝：指向已存在的内存地址，值跟随变化。
深拷贝：申请了一个新的内存区域存放值，值不跟随变化。

BeanUtils.copyProperties是浅拷贝
```

14、JVM中的-Xms 、-Xmx 参数该如何设置？

```
-Xms参数用于设置堆的初始内存值，默认为物理内存的1/64（且小于1G）。
-Xmx参数用于设置堆的最大内存值，默认值为物理内存的1/4（且小于1G）。
GC时，工作线程会暂停，如果GC太频繁，工作线程的效率和响应时间肯定会受影响，所以jvm性能调优的最基本条件就是要尽可能
地减少垃圾回收的次数。
如果将Xms和Xmx参数设置为不同的值，堆内存不足时会进行扩容，每次jvm向操作系统申请内存时都需要一定的开销，引发内存抖动。
所以要将-xms和-xmx设置成相同的值。
```

15、G1垃圾回收期如何使用？

```
G1（Garbage-First）垃圾回收器是Java HotSpot虚拟机中的一种面向服务器的垃圾收集器，
它主要针对配备多核处理以及大容器内存的机器，旨在提供可预测的停顿时间，同时实现高吞吐量。
以下是G1垃圾回收器的使用方法及特点：

一、G1垃圾回收器的使用方法
1. 参数设置
启用G1垃圾回收器：通过JVM启动参数-XX:+UseG1GC来启用G1垃圾回收器。
调整分区大小：使用-XX:G1HeapRegionSize参数来指定分区大小，分区大小在1MB到32MB之间，且必须是2的N次幂。默认情况下，
JVM会根据堆大小自动划分分区，最多可以有2048个分区。
设置目标暂停时间：通过-XX:MaxGCPauseMillis参数来设置G1垃圾回收器的目标暂停时间，默认值为200毫秒。
G1会根据这个值来优化回收过程，尽量将GC导致的停顿时间控制在这个范围内。
调整新生代大小：使用-XX:G1NewSizePercent和-XX:G1MaxNewSizePercent参数来调整新生代的初始大小和最大大小。默认情况下，
新生代的初始大小占堆内存的5%，最大大小占堆内存的60%。
其他相关参数：如-XX:SurvivorRatio用于设置Survivor区与Eden区的比例（默认为8:1:1），-XX:MaxTenuringThreshold用于设置
对象晋升到老年代的年龄阈值（默认为15）等。
2. 回收流程
G1垃圾回收器的回收流程主要包括以下几个步骤：

初始标记（Initial Mark, STW）：暂停所有的其他线程，并记录下GC Roots直接能引用的对象。
并发标记（Concurrent Marking）：与应用程序并发执行，标记出存活的对象。
最终标记（Remark, STW）：暂停所有的其他线程，处理并发标记阶段产生的变动，并修正标记结果。
筛选回收（Cleanup, STW）：根据用户所期望的GC停顿时间来制定回收计划，选择回收价值最大的Region进行回收。
二、G1垃圾回收器的特点
并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。
分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但还是保留了分代的概念，将堆内存划分为年轻代和老年代。
空间整合：G1整体上是基于“标记-整理”算法实现的收集器，从局部看，则是基于“复制”算法实现的。这种混合算法可以有效减少
内存碎片。
可预测的停顿时间：G1能够建立可预测的停顿时间模型，允许用户明确指定在一个长度为M毫秒的时间片段内完成垃圾收集。
三、使用场景
G1垃圾回收器适用于以下场景：

堆内存较大（如8GB以上）的情况。
停顿时间要求较高（如500毫秒以内）的情况。
垃圾回收时间特别长（超过1秒）的情况。
对象分配和晋升的速度变化非常大的情况。
四、注意事项
在设置目标暂停时间时，需要考虑到实际的应用场景和性能要求，避免设置过低导致频繁GC和性能下降。
在使用G1垃圾回收器时，建议对JVM的启动参数进行合理的配置和调整，以达到最优的性能表现。
总之，G1垃圾回收器是一种高效、灵活的垃圾收集器，能够满足多种复杂应用场景下的性能要求。在使用时，
需要根据实际情况进行合理的配置和调整。
```

