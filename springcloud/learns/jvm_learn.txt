什么是程序计数器?
线程私有的，每个线程一份，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。

你能给我详细的介绍Java堆吗?
线程共享的区域:主要用来保存对象实例，数组等，内存不够则抛出OutOfMemoryError异常。
组成:年轻代+老年代
年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区
老年代主要保存生命周期长的对象，一般是一些老的对象
Jdk1.7和1.8的区别
1.7中有有一个永久代，存储的是类信息、静态变量、常量、编译后的代码
1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出


1、什么是虚拟机栈
1)每个线程运行时所需要的内存，称为虚拟机栈
2)每个栈由多个栈帧(frame)组成，对应着每次方法调用时所占用的内存
3)每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

2.垃圾回收是否涉及栈内存?
垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放
先进后出

栈帧1(参数、局部变量、返回地址)
栈帧2
栈帧3

3.栈内存分配越大越好吗?
未必，默认的栈内存通常为1024k
栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，
如果把栈内存改为2048k，那么能活动的栈帧就会减半

4.方法内的局部变量是否线程安全?
如果方法内局部变量没有逃离方法的作用范围，它是线程安全的如果是局部变量引用了对象，
并逃离方法的作用范围，需要考虑线程安全

5.栈内存溢出情况
栈帧过多导致栈内存溢出，典型问题:递归调用
栈帧过大导致栈内存溢出

6.堆栈的区别是什么?
栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会
栈内存是线程私有的，而堆内存是线程共有的。
两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。
栈空间不足:java.lang.StackOverFlowError。
堆空间不足:java.lang.OutOfMemoryError.


1.能不能解释一下方法区?
方法区(Method Area)是各个线程共享的内存区域
主要存储类的信息、运行时常量池
虚拟机启动的时候创建，关闭虚拟机时释放
如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError:Metaspace
2.介绍一下运行时常量池
常量池:可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名方法名、参数类型、字面量等信息
当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

你听过直接内存吗?
并不属于JVM中的内存结构，不由VM进行管理。是虚拟机的系统内存
常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理

1.什么是类加载器
JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到IM中，从而让Java程序能够启动起来。
2.类加载器有哪些
启动类加载器(BootStrap ClassLoader):加载JAVA HOME/jre/lib目录下的库
扩展类加载器(ExtClassLoader):主要加载JAVA HOME/jre/lib/ext目录中的类
应用类加载器(AppClassLoader):用于加载classPath下的类
自定义类加载器(CustomizeClassLoader):自定义类继承ClassLoader，实现自定义类加载规则。

1.什么是双亲委派模型?
加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，
则会子加载器尝试加载该类继续向上委托，如果该类委托上级没有被加载

2.JVM为什么采用双亲委派机制?
通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
为了安全，保证类库API不会被修改

说一下类装载的执行过程?
加载:查找和导入class文件
验证:保证加载类的准确性
准备:为类变量分配内存并设置类变量初始值
解析:把类中的符号引用转换为直接引用
初始化:对类的静态变量，静态代码块执行初始化操作
使用:JVM 开始从入口方法开始执行用户的程序代码卸载:当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象.

对象什么时候可以被垃圾器回收?
如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾如果定位了垃圾，则有可能会被垃圾回收器回收。
定位垃圾的方式有两种
引用计数法
可达性分析算法

哪些对象可以作为 GC Root ?
虚拟机栈(栈帧中的本地变量表)中引用的对象方法区中类静态属性引用的对象
方法区中常量引用的对象
本地方法栈中 JNI(即一般说的 Native 方法)引用的对象


JVM 垃圾回收算法有哪些?
标记清除算法:垃圾回收分为2个阶段，分别是标记和清除,效率高,有磁盘碎片，内存不连续
标记整理算法:标记清除算法一样，将存活对象都向内存另一端移动，然后清理边界以外的垃圾，
无碎片，对象需要移动，效率低 (老年代常用)
复制算法:将原有的内存空间一分为二，每次只用其中的一块,正在使用的对象复制到另一个内存空间中，
然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收;无碎片，内存使用率低  (年轻代常用)

说一下JVM中的分代回收
一、堆的区域划分
1.堆被分为了两份:新生代和老年代【1:2】
2.对于新生代，内部又被分为了三个区域。Eden区，幸存者区survivor(分成from和to)【8:1:1)
二、对象回收分代回收策略
1.新创建的对象，都会先分配到eden区
2.当伊甸园内存不足，标记伊甸园与from(现阶段没有)的存活对象
3.将存活对象采用复制算法复制到to中，复制完毕后，伊甸园和 from 内存都得到释放
4.经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将其复制到from区
5.当幸存区对象熬过几次回收(最多15次)，晋升到老年代(幸存区内存不足或大对象会提前晋升

MinorGc、Mixed Gc、FullGC的区别是什么
MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短(STW)
Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有
FullGC:新生代 +老年代完整垃圾回收，暂停时间长(STW)，应力避免

说一下JVM有哪些垃圾回收器?
在jvm中，实现了多种垃圾收集器，包括
串行垃圾收集器:Serial GC、Serial Old GC
并行垃圾收集器:Parallel Old GC、ParNewGC (java8默认的垃圾回收器)
CMS(并发)垃圾收集器:CMS GC，作用在老年代
G1垃圾收集器，作用在新生代和老年代

详细聊一下G1垃圾回收器
1.应用于新生代和老年代，在JDK9之后默认使用G1
2.划分成多个区域，每个区域都可以充当eden，survivor，old，humongous其中 humongous 专为大对象准备
3.采用复制算法
4.响应时间与吞吐量兼顾
5.分成三个阶段:新生代回收(stw)、并发标记(重新标记stw)、混合收集
如果并发失败(即回收速度赶不上创建新对象速度)，会触发FuGC

强引用、软引用、弱引用、虚引用的区别?
强引用:只要所有 GC Roots 能找到，就不会被回收
软引用:需要配合SoftReference使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象
弱引用:需要配合WeakReference使用，只要进行了垃圾回收，就会把弱引用对象回收
虚引用:必须配合引用队列使用，被引用对象回收时，会将虚引用入队由ReferenceHandler线程
调用虚引用相关方法释放直接内存

JVM 调优的参数可以在哪里设置参数值
war包部署在tomcat中设置修改TOMCAT HOME/bin/catalina.sh文件
jar包部署在启动参数设置java -Xms512m -Xmx1024m -jar xxxx,jar

用的 JM 调优的参数都有哪些?
设置堆空间大小
虚拟机栈的设置
年轻代中Eden区和两个Survivor区的大小比例
年轻代晋升老年代阈值
设置垃圾回收收集器

说一下 JVM 调优的工具?
命令工具
jps  进程状态信息
jstack  查看java进程内线程的堆栈信息
jmap  查看堆转信息
jhat  堆转储快照分析工具
jstat JVM统计监测工具
可视化工具
jconsol 用于对jvm的内存，线程，类 的监控.
VisualVM能够监控线程，内存情况

java内存泄露的排查思路?
内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况
1、通过jmap或设置jvm参数获取堆内存快照dump、
2、通过工具，VisuaIVM去分析dump文件，VisualVM可以加载离线的dump文件
3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题
4、找到对应的代码，通过阅读上下文的情况，进行修复即可

CPU飙高排查方案与思路?
1.使用top命令查看占用cpu的情况
2.通过top命令查看后，可以查看是哪一个进程占用cpu较高
3.使用ps命令查看进程中的线程信息
4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题