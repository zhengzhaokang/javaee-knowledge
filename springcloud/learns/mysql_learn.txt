如何定位慢查询?
1.介绍一下当时产生问题的场景(我们当时的一个接口测试的时候非常的慢，
2.压测的结果大概5秒钟)我们系统中当时采用了运维工具(Skywalking)，
可以监测出哪个接口，最终因为是sql的问题
3.在mysql中开启了慢日志查询，我们设置的值就是2秒，
一旦sql执行超过2秒就会记录到日志中(调试阶段)

那这个SQL语句执行很慢,如何分析呢?
1.可以采用MySQL自带的分析工具 EXPLAIN
2.通过key和key len检查是否命中了索引(索引本身存在是否有失效的情况)
3.通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描通过extra建议判断，
是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复

了解过索引吗?(什么是索引)
1.索引(index)是帮助MySQL高效获取数据的数据结构(有序)
2.提高数据检索的效率，降低数据库的I0成本(不需要全表扫描)
3.通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗
索引的底层数据结构了解过嘛 ?
MySQL的InnoDB引擎采用的B+树的数据结构来存储索引
1.阶数更多，路径更短
2.磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据
3.B+树便于扫库和区间查询，叶子节点是一个双向链表

什么是聚簇索引什么是非聚簇索引?
聚簇索引(聚集索引):数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个
非聚簇索引(二级索引):数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个
知道什么是回表查询嘛 ?
通过非聚簇索引找到对应的主键值，到聚集索引中查找整行数据，这个过程就是回表


知道什么叫覆盖索引嘛 ?
覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到
1.使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。
2.如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*
MYSQL超大分页怎么处理?
问题:在数据量比较大时，limit分页查询，需要对数据进行排序，效率低
解决方案:覆盖索引+子查询

索引创建原则有哪些?
重要1).数据量较大，且查询比较频繁的表
重要2).常作为查询条件、排序、分组的字段
3).字段内容区分度高
4).内容较长，使用前缀索引
5).尽量联合索引
6).要控制索引的数量
重要
重要
7).如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它


什么情况下索引会失效?
1.违反最左前缀法则
2.范围查询右边的列，不能使用索引
3.不要在索引列上进行运算操作，索引将失效
4.字符串不加单引号，造成索引失效。(类型转换)4)
5.以%开头的Like模糊查询，索引失效


谈一谈你对sql的优化的经验
1.表的设计优化，数据类型的选择
2.索引优化，索引创建原则
3.sql语句优化，避免索引失效，避免使用select*
4.主从复制、读写分离，不让数据的写入，影响读操作
5分库分表

事务的特性是什么?可以详细说一下吗?
原子性( Atomicity )
-致性( Consistency)
隔离性( lsolation)
持久性( Durability)


并发事务带来哪些问题?怎么解决这些问题呢?MySQL的默认隔离级别是?
并发事务的问题:
脏读:一个事务读到另外一个事务还没有提交的数据。I
日不可重复读:一个事务先后读取同一条记录，但两次读取的数据不同
③ 幻读:一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。
隔离级别:
READ UNCOMMITTED 未提交读脏读、不可重复读、幻读
②READ COMMITTED 读已提交
不可重复读、幻读
③ REPEATABLE READ 可重复读幻读
日SERIALIZABLE 串行化


redo log
这节视频没听懂，有没有人理角
重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性该日志文件由两部分组成:
重做日志缓冲(redo log bufer)以及重做日志文件(redolog file)前者是在内存中，后者在磁盘中。
当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。

undo log
回滚日志，用于记录数据被修改前的信息,作用包含两个:提供回滚 和 VGC(多版本并发控制)。
undoloq和redoloq记录物理日志不一样，它是逻辑日志
可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然当update一条记录时，
它记录一条对应相反的update记录。当执行roback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

undo log和redo log的区别
1.redo log:记录的是数据页的物理变化，服务机可用来同步数据
2.undo log:记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据
3.redo log保证了事务的持久性，undolog保证了事务的原子性和一致性


事务中的隔离性是如何保证的呢?(你解释一下MVCC)
MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突
1.隐藏字段:
trx id(事务id)，记录每一次操作的事务id，是自增的
roll pointer(回滚指针)，指向上一个版本的事务版本记录地址e 
2.undo log:
回滚日志，存储老版本数据
版本链:多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll pointer指针形成一个链表
3.readView解决的是一个事务查询选择版本的问题
根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据?
不同的隔离级别快照读是不一样的，最终的访问的结果不一样
RC:每一次执行快照读时生成ReadView
RR:仅在事务中第一次执行快照读时生成ReadView，后续复用


主从同步原理?
MySQL主从复制的核心就是二进制日志binlog(DDL(数据定义语言)语句和 DML(数据操纵语言)语句)
1.主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。
2.从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log
3.从库重做中继日志中的事件，将改变反映它自己的数据
4.异步复制，半同步复制（可以指定从库读取的数量）、同步复制


你们项目用过分库分表吗
业务介绍
1.根据自己简历上的项目，想一个数据量较大业务(请求数多或业务累积大)
2，达到了什么样的量级(单表1000万或超过20G)
具体拆分策略
1.水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题
2.水平分表，解决单表存储和性能的问题  sharding-sphere、mycat
3.垂直分库，根据业务进行拆分，高并发下提高磁盘I0和网络连接数3.
4.垂直分表，冷热数据分离，多表互不影响