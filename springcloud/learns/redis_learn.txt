缓存穿透：
解决方案，
1.查询不到缓存时，返回空值，并设置一定的过期时间。
2.使用布隆过滤器，bitmap，多次hash放入bitmap中，可能存在误判，可以设置误判率。
缓存击穿：
缓存没有，数据库有。
1.使用互斥锁，load db时，加分布式锁，一致性高，性能低点。适用于金融系统，交易系统等。
2.使用key本身不过期，逻辑过期。当逻辑过期时，则另开一个线程加分布式锁进行数据同步。
性能比较高，做不过强一致性。适用于并发高的场景。
缓存雪崩：大量key同时过期。
解决方案：
1.给key设置不同的过期时间。
2.利用redis集群提高服务可用性
3.给缓存业务添加降级限流策略。
4.给业务添加多级缓存，如Guava或Caffeine。
Redis和mysql双写一致性
1.强制一致性，比如711优惠券活动的库存，这个需要实时的进行同步数据，为了保证数据库的强一致性，
当时使用的是Redission提供的读写锁来保证数据的一致性。
读时用读锁，其他线程可以共享读，写时用写锁，会阻塞其他线程读写操作。
2.最终一致性
使用MQ异步通知
使用canal中间件，不要修改业务代码，通过读取binlog数据更新缓存。

Rdb执行原理
Bgsave主进程fork得到子进程，子进程共享主进程的内存数据，完成fork后，读取内存数据并写入磁盘。
Fork采用copy-on-write技术
当主进程执行读时，访问共享内存；当主进程执行写操作时，会拷贝一份数据，执行写操作。
AOF，文件追加
Aof文件比rdb大的多，可以通过执行bgrewriteaof命令，执行Aof重写。配置文件大小或者比例触发重写。
set num 1 set a b Set num2 会重写成 meet num 2 a b 
项目中使用 Rdb + Aof同时开启.

Redis删除策略:
1.惰性删除:过期之后的数据，不会立即删除，再次被访问，如果过期，才会被删除
2.定期删除:每隔一段时间，一定量的key进行检查，删除其中过期的key
slow模式:执行频率默认 10hz(100ms一次), 并每次耗时不超过25ms，可以通过redis.conf的hz配置修改
Fast模式:执行频率不固定，但间隔时间不低于2ms,每次耗时不超过1ms

redis默认是 惰性删除和定期删除

淘汰策略:
1.noeviction:不淘汰，默认策略，推荐使用
2.volatile-ttl, ttl越小越线淘汰
3.allkeys-random:全体key，随机进行淘汰. (没有明显的冷热数据)
4.volatile-random:设置了ttl的key,随机淘汰
5.allkeys-lru:对全体key,基于lru算法淘汰.推荐使用
6.volatile-lru (有置顶的需求，同时置顶需求不设置过期时间)
7:allkeys-lfu:对全体key,基于lfu算法淘汰 
8.volatile-lfu （有短时高频访问的数据，可以用7或8）

如果数据库有1000万数据，Redis之缓存了20w的数据，如果保证redis中的数据都是热点数据?
使用allkey-lru（最近最少使用的数据）淘汰策略，留下来的都是热点数据

Redis的内存用完了会发生什么?
主要看数据的淘汰策略是什么，如果是默认的配置Noeviction，则直接报错

Redis 分布式锁， setnx + 过期时间， 唯一的key 通过
Redssion框架，看门狗机制，自动过期续期。
加锁设置过期时间，是基于Lua脚本实现的.
利用hash结构记录线程id和重入次数。
主从一致性：红锁，过半机制
自定义注解 @RedisDistriLock AOP切面实现分布式锁.
AP思想 Redis  也可以CP的 Zookeeper实现

介绍-下redis的主从同步
单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，
实现读写分-般都是一主多从，主节点负责写数据，从节点负责读数据。

能说一下，主从同步数据的流程
全量同步:
1.从节点请求主节点同步数据(replication id、 offset)
2.主节点判断是否是第一次请求，是第一次就与从节点同步版本信息(replication id和offset)
3.主节点执行bgsave，生成rdb文件后，发送给从节点去执行
4.在rdb生成执行期间，主节点会以命令的方式记录到缓冲区(一个日志文件)
5.把生成之后的命令日志文件发送给从节点进行同步
增量同步:
1.从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值
2.主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步 （如 offset 100->120）

怎么保证Redis的高并发高可用?
哨兵模式:实现主从集群的自动故障恢复(监控、自动故障恢复、通知)
你们使用redis是单点还是集群，哪种集群?
主从(1主1从)+哨兵就可以了，单节点不超过10G内存，
如果Redis内存不足则可以给不同服务分配独立的Redis主从节点
redis集群脑裂，该怎么解决呢?
集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，
所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，
这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，
sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失
解决:我们可以修改redis的配置，可以[设置最少的从节点数量]以及[缩短主从数据同步的延迟时间]，
达不到要求就拒绝请求就可以避免大量的效据丢失(相当于从异步复制 -> 改成了半同步复制)

redis的分片集群有什么作用？
集群中有多个master，每个master保存不同数据
每个master都可以有多个slave节点
master之间通过ping监测彼此健康状态
客户端请求可以访问集群任意节点，最终都会被转发到正确节点

Redis分片集群中数据是怎么存储和读取的?
Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽
将16384个插槽分配到不同的实例
读写数据:根据key的有效部分计算哈希值，对16384取余(CRC16校验, 有效部分，如果key前面有太括号，
大括号的内容就是有效部分，如果没有，则以key本身做为有效部分)余数做为插槽，寻找插槽所在的实例

Redis是单线程的，但是为什么还那么快?
Redis是纯内存操作，执行速度非常快
采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题
使用I/O多路复用模型，非阻塞I0

能解释一下I/O多路复用模型?
1.I/O多路复用
是指利用单个线程来同时监听多个Socket，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。
目前的I/0多路复用都是采用的epoll模式实现，它会在通知用户进程Socket就绪的同时，
把已就绪的Socket写入用户空间，不需要挨个遍历Socket来判断是否就绪，提升了性能。
2. Redis网络模型
就是使用I/〇多路复用结合事件的处理器来应对多个Socket请求
连接应答处理器>
命令回复处理器，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件
命令请求处理器，在Redis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然
是单线程