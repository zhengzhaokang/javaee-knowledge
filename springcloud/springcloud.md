1、**什么是Spring Cloud？**

```
Spring Cloud是一个微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体（微服务全家桶）。它不是新的框架，
而是一个全家桶式的技术栈，包含了很多组件，是一系列框架的有机组合，利用Spring Boot的开发便利性巧妙地简化了分布式系统
基础设施的开发。

Spring Cloud的核心特点包括：
服务治理：
服务注册与发现：通过Eureka、Nacos等组件实现服务的注册与发现，使得服务间的调用更加灵活和可靠。
负载均衡：如Ribbon、Feign等组件，可以在服务间进行负载均衡，提高系统的性能和可用性。
配置管理：
Spring Cloud Config等组件支持使用Git等版本控制系统来存储和分发配置信息，实现配置的外部化和动态更新。
断路器：
如Hystrix、Sentinel等组件，可以在服务调用失败时自动进行熔断，防止故障在系统中蔓延。
智能路由：
Zuul、Gateway等网关组件提供智能路由功能，可以根据不同的条件将请求路由到不同的服务实例。
消息总线：
Spring Cloud Bus等组件可以在集群中传播状态变化，实现配置的动态更新和服务的协同工作。
其他功能：
Spring Cloud还提供了分布式会话、集群状态管理、一次性Token、全局一致性锁、领导选举等功能，以支持复杂的分布式系统需求。
Spring Cloud的组件和子项目：
Spring Cloud包含了许多子项目，这些子项目各自独立进行内容更新与迭代，并维护着自己的发布版本号。一些重要的子项目包括：

Spring Cloud Netflix：针对Netflix的多个开源组件（如Eureka、Hystrix、Zuul等）提供的开发工具包。
Spring Cloud Alibaba：提供了一套完整的微服务解决方案，包括服务注册发现（Nacos）、流量控制（Sentinel）、消息传递
（RocketMQ）等功能。
Spring Cloud Config：配置管理工具。
Spring Cloud Bus：事件、消息总线。
Spring Cloud Gateway：基于Spring Framework 5, Project Reactor和Spring WebFlux构建的API网关，旨在提供一种简单而有效的方式
来路由和过滤到API的流量。
使用Spring Cloud的好处：
简化开发：Spring Cloud通过提供一系列开箱即用的组件和工具，极大地简化了分布式系统的开发。
提高可维护性：通过将系统拆分为多个微服务，每个服务都可以独立开发和部署，降低了系统的复杂性和维护成本。
提高可扩展性：微服务架构使得系统可以更加容易地进行水平扩展，以满足不断增长的业务需求。
提高可用性：通过负载均衡、断路器、智能路由等功能，提高了系统的可用性和容错能力。
综上所述，Spring Cloud是微服务架构中不可或缺的一部分，它提供了一套全面而强大的工具集，帮助开发者快速构建和部署分布式系统。
```

2、**Spring Cloud和Dubbo的区别**

```
Spring Cloud和Dubbo作为微服务架构中的两大主流框架，它们各自具有独特的特点和优势，也存在一些明显的区别。以下是它们之间
几个主要方面的对比：

一、初始定位与关注点
Spring Cloud：
定位为微服务架构下的一站式解决方案，旨在帮助开发者快速构建和部署微服务应用。
依托于Spring平台，具备更加完善的生态体系，包括服务注册与发现、配置中心、负载均衡、断路器、网关、分布式追踪等多个组件。
Dubbo：
是SOA（面向服务的架构）时代的产物，主要关注于服务的调用和治理。
最初只是一个RPC（远程过程调用）框架，但随着发展，逐渐提供了分布式服务治理的完整解决方案。
二、生态环境
Spring Cloud：
生态体系丰富，功能完善，集成了Spring Boot的诸多特性，易于上手和使用。
社区活跃度很高，有很多开发者和公司在使用和贡献这个框架，同时也有很多周边的工具和插件。
Dubbo：
早期生态相对匮乏，但随着阿里巴巴等企业的推动，逐渐丰富起来。
现在Dubbo也支持多种服务治理组件，如Nacos、Zookeeper、Eureka等，但整体上在生态丰富度上可能稍逊于Spring Cloud。
三、调用方式与性能
Spring Cloud：
采用HTTP协议做远程调用，接口一般是Rest风格，比较灵活。
在性能上，由于HTTP协议的开销，可能略逊于Dubbo。
Dubbo：
采用Dubbo协议，接口一般是Java的Service接口，格式固定。
调用时采用Netty的NIO方式，性能较好，特别是在处理大量并发请求时。
四、组件差异
注册中心：
Spring Cloud常用Eureka、Consul等作为服务注册中心。
Dubbo则支持Nacos、Zookeeper、Eureka等多种注册中心。
其他组件：
Spring Cloud还提供了配置中心（Spring Cloud Config）、负载均衡（Ribbon/Feign）、断路器（Hystrix/Sentinel）、
网关（Zuul/Gateway）等组件。
Dubbo则更侧重于服务调用和治理，提供了负载均衡、服务路由、容错机制等功能。
五、灵活性与可定制性
Spring Cloud：
功能丰富，但可能在一些特定场景下显得较为庞大和复杂。
提供了大量的配置项和扩展点，但也可能增加了学习和使用的难度。
Dubbo：
相对灵活，可定制性强。
架构设计允许各个功能模块根据需求进行扩展和定制，以适应不同的业务场景。
综上所述，Spring Cloud和Dubbo在微服务架构中各有千秋。选择哪个框架主要取决于项目的具体需求、团队的技术栈以及对框架的熟悉
程度。在实际应用中，也可以根据项目的不同阶段和需求变化，灵活选择或切换框架。
```

3、**REST和RPC的区别**

- REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。
- REST调用系统性能较低，RPC调用效率比REST高。
- REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。
- REST可以和Swagger等工具整合，自动输出接口API文档。

```
REST（Representational State Transfer）和RPC（Remote Procedure Call Protocol）是两种在分布式系统中常用的通信协议或架构
风格，它们之间存在显著的区别。以下是对REST和RPC区别的详细分析：

1. 所属类别与定义
REST：
REST是一种软件架构风格，而不是协议。它代表“表述性状态转移”，强调资源的表述和状态转移。
REST架构风格包含了一组约束，如客户端-服务器结构、无状态性、可缓存性、分层系统等，这些约束共同定义了RESTful系统的行为。
RPC：
RPC是一种远程过程调用协议，允许一个程序通过网络从远程计算机程序上请求服务，就像调用本地服务一样。
RPC可以基于多种协议进行传输，如TCP/UDP或HTTP，但本质上它关注的是远程函数的调用。
2. 通信方式与关注点
REST：
基于HTTP协议，使用标准的HTTP方法（如GET、POST、PUT、DELETE）来操作资源。
强调资源的表述和状态转移，客户端通过操作资源的表述来与服务器进行通信。
客户端和服务器之间的通信是无状态的，即服务器不会保存客户端的状态信息。
RPC：
客户端直接调用远程服务器上的函数或方法，就像调用本地函数一样。
RPC关注于远程函数的调用和结果的返回，客户端需要知道远程函数的名称和参数。
RPC可以是有状态的，也可以是无状态的，这取决于具体的实现。
3. 标准化与灵活性
REST：
REST有一套相对标准化的约束和原则，如使用HTTP方法、URI来标识资源等。
由于其标准化和灵活性，RESTful API可以很容易地被不同的客户端和服务器理解和实现。
RPC：
RPC的标准化程度相对较低，不同的RPC框架可能有不同的实现方式和约束。
RPC的灵活性较高，可以基于多种协议进行传输，但这也增加了实现的复杂性。
4. 使用场景与性能
REST：
适用于需要对外提供统一接口的场景，如Web API、开放平台等。
由于HTTP协议的开销，REST在性能上可能略逊于RPC。
RPC：
适用于内部系统之间的复杂通信和函数调用，如微服务架构中的服务间调用。
RPC通常具有更高的性能，因为它可以传输更少的数据和减少网络延迟。
5. 安全性与扩展性
REST：
REST架构风格本身并不直接涉及安全性问题，但可以通过HTTPS等协议来增强安全性。
REST的扩展性较好，可以很容易地添加新的资源和操作。
RPC：
RPC的安全性取决于具体的实现和传输协议。
RPC的扩展性可能受到框架和协议的限制，但现代RPC框架通常提供了良好的扩展性支持。
综上所述，REST和RPC在所属类别、通信方式、标准化程度、使用场景、性能以及安全性与扩展性等方面都存在明显的区别。
在选择使用哪种方式时，需要根据具体的项目需求和技术栈来进行权衡和选择。
```

**4、SpringCloud如何实现服务的注册和发现**

```
服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。
这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。
调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。
```

5、**什么是服务熔断和服务降级？**

```
熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点
微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制
通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，
就会启动熔断机制。
服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback
回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。

Hystrix相关注解：

@EnableHystrix：开启熔断
@HystrixCommand(fallbackMethod=”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），
就会执行fallback函数，返回错误提示。
```

**6、什么是Hystrix？它如何实现容错？**

```
Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在
复杂的分布式系统中实现弹性。

现在假设由于某种原因，employee-producer公开的服务会抛出异常。我们在这种情况下使用Hystrix定义了一个回退方法。
这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。
```

7、**服务网关的作用**

```
简化客户端调用复杂度，统一处理外部请求。
数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。
多渠道支持，针对不同的客户端提供不同的网关支持。
遗留系统的微服务化改造，可以作为新老系统的中转组件。
统一处理调用过程中的安全、权限问题。
Spring Cloud中的网关有：Zuul和Spring Cloud Gateway，最新版本中推荐使用后者。
```

8、**ribbon和feign区别**

```
Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value="服务名称") 使用RestTemplate调用远程服务对应的方法。
feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient("指定服务名")
Ribbon和Feign的区别：

Ribbon和Feign都是用于调用其他服务的，不过方式不同。

启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。
服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。
调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。
Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，

不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。
```

9、**ribbon的负载均衡策略**

```
RoundRobinRule: 轮询策略，Ribbon以轮询的方式选择服务器，这个是默认值。所以示例中所启动的两个服务会被循环访问;
RandomRule: 随机策略，也就是说Ribbon会随机从服务器列表中选择一个进行访问;
BestAvailableRule: 最大可用策略，即先过滤出故障服务器后，选择一个当前并发请求数最小的;
WeightedResponseTimeRule: 带有加权的轮询策略，对各个服务器响应时间进行加权处理，然后在采用轮询的方式来获取相应的服务器;
AvailabilityFilteringRule: 可用过滤策略，先过滤出故障的或并发请求大于阈值的一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个;
```

10、**简述什么是CAP,并说明Eureka包含CAP中的哪些?**

```
CAP理论：一个分布式系统不可能同时满足C (一致性),A(可用性),P(分区容错性).由于分区容错性P在分布式系统中是必须要保证的,
因此我们只能从A和C中进行权衡.

Eureka 遵守 AP

Eureka各个节点都是平等的,几个节点挂掉不会影响正常节点的工作,神域的节点依然可以提供注册和查询服务。
而Eureka的客户端在向某个Eureka 注册或查询是如果发现连接失败,则会自动切换至其他节点，只要有一台Eureka还在,就能保证注册
服务可用(保证可用性),只不过查的信息可能不最新的不保证强一致性)。
```